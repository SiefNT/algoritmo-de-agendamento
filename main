import tkinter as tk
from functools import partial


class JanelaPrincipal:
    def __init__(self, raiz):
        self.raiz = raiz
        raiz.geometry("550x400+450+200")
        self.frame = tk.Frame(self.raiz)

        # Título principal
        tk.Label(self.raiz, text="ALGORITMOS DE AGENDAMENTO", font="Verdana 14 bold").grid(row=0, column=0, padx=50,
                                                                                           pady=20, columnspan=2)

        # Espaços para alinhamento
        tk.Label(self.raiz, text="").grid(row=1, column=0)
        tk.Label(self.raiz, text="").grid(row=2, column=0)

        # Botões estilizados
        self.create_button("Round Robin", "ROUND-ROBIN", row=3)
        self.create_button("FCFS", "FCFS", row=5)
        self.create_button("SJF", "SJF", row=7)
        self.create_button("SRTF", "SRTF", row=9)
        self.create_button("Priority", "Priority", row=11)

        self.frame.grid()

    def create_button(self, text, command, row):
        button_style = {"font": "Verdana 12 bold", "bg": "lightblue", "width": 15}
        tk.Button(self.raiz, text=text, command=partial(self.roundrobin, command), **button_style).grid(row=row,
                                                                                                        column=0,
                                                                                                        pady=5,
                                                                                                        padx=100)

    def roundrobin(self, algo):
        self.raiz.withdraw()
        self.rr = tk.Toplevel(self.raiz)
        bb = Agendador(self.raiz, self.rr, algo)
class Agendador:
    def __init__(self, raiz, rr, algo):
        self.raiz = raiz
        self.rr = rr
        self.algo = algo
        rr.geometry("+450+200")
        self.frame = tk.Frame(self.rr)
        tk.Label(self.rr, text="").grid()
        tk.Label(self.rr, text="Processos", font="verdana 10 bold").grid(row=1, column=0)
        tk.Label(self.rr, text="Tempo de Chegada", font="verdana 10 bold").grid(row=1, column=1)
        tk.Label(self.rr, text="  ").grid(row=1, column=2)
        tk.Label(self.rr, text="Tamanho Processo", font="verdana 10 bold").grid(row=1, column=3)
        tk.Label(self.rr, text="  ").grid(row=1, column=4)
        if "ROUND-ROBIN" == algo:
            tk.Label(self.rr, text="Time Quantum", font="verdana 10 bold").grid(row=1, column=5)
        if "Priority" == algo:
            tk.Label(self.rr, text="Priority", font="verdana 10 bold").grid(row=1, column=5)
        tk.Label(self.rr, text="").grid()
        tk.Label(self.rr, text="P1", font=" verdana 10 bold").grid(row=3, column=0)
        self.a11 = tk.IntVar()
        self.a22 = tk.IntVar()
        self.a33 = tk.IntVar()
        self.a44 = tk.IntVar()
        self.a55 = tk.IntVar()
        self.b11 = tk.IntVar()
        self.b22 = tk.IntVar()
        self.b33 = tk.IntVar()
        self.b44 = tk.IntVar()
        self.b55 = tk.IntVar()
        self.c11 = tk.IntVar()
        self.p11 = tk.IntVar()
        self.p22 = tk.IntVar()
        self.p33 = tk.IntVar()
        self.p44 = tk.IntVar()
        self.p55 = tk.IntVar()

        self.a1 = tk.Entry(self.rr, textvariable=self.a11).grid(row=3, column=1)
        self.b1 = tk.Entry(self.rr, textvariable=self.b11).grid(row=3, column=3)
        if ("ROUND-ROBIN" == algo):
            self.c1 = tk.Entry(self.rr, textvariable=self.c11).grid(row=3, column=5)
        tk.Label(self.rr, text="").grid()
        tk.Label(self.rr, text="P2", font=" verdana 10 bold").grid(row=5, column=0)
        self.a2 = tk.Entry(self.rr, textvariable=self.a22).grid(row=5, column=1)
        self.b2 = tk.Entry(self.rr, textvariable=self.b22).grid(row=5, column=3)
        tk.Label(self.rr, text="").grid()
        tk.Label(self.rr, text="P3", font=" verdana 10 bold").grid(row=7, column=0)
        self.a3 = tk.Entry(self.rr, textvariable=self.a33).grid(row=7, column=1)
        self.b3 = tk.Entry(self.rr, textvariable=self.b33).grid(row=7, column=3)
        tk.Label(self.rr, text="").grid()
        tk.Label(self.rr, text="P4", font=" verdana 10 bold").grid(row=9, column=0)
        self.a4 = tk.Entry(self.rr, textvariable=self.a44).grid(row=9, column=1)
        self.b4 = tk.Entry(self.rr, textvariable=self.b44).grid(row=9, column=3)
        tk.Label(self.rr, text="").grid()
        tk.Label(self.rr, text="P5", font=" verdana 10 bold").grid(row=11, column=0)
        self.a5 = tk.Entry(self.rr, textvariable=self.a55).grid(row=11, column=1)
        self.b5 = tk.Entry(self.rr, textvariable=self.b55).grid(row=11, column=3)
        tk.Label(self.rr, text="").grid()
        z = 0
        self.choice = "HV"
        if "Priority" == algo:
            self.p1 = tk.Entry(self.rr, textvariable=self.p11).grid(row=3, column=5)
            self.p2 = tk.Entry(self.rr, textvariable=self.p22).grid(row=5, column=5)
            self.p3 = tk.Entry(self.rr, textvariable=self.p33).grid(row=7, column=5)
            self.p4 = tk.Entry(self.rr, textvariable=self.p44).grid(row=9, column=5)
            self.p5 = tk.Entry(self.rr, textvariable=self.p55).grid(row=11, column=5)
            tk.Label(self.rr, text="Prioridade de acordo com :", font="verdana 10 bold").grid(row=13, column=1)
            tk.Label(self.rr, text="").grid()
            self.butt = tk.Button(self.rr, text="Maior valor", command=partial(self.Choices, "MV")).grid(row=15,
                                                                                                         column=0)
            self.butt = tk.Button(self.rr, text="Menor valor", command=partial(self.Choices, "VL")).grid(row=15,
                                                                                                         column=1)
            tk.Label(self.rr, text="").grid()
            z = 5
        self.button1 = tk.Button(self.rr, text="VOLTAR", command=self.voltar).grid(row=13 + z, column=0)
        self.wt = tk.Button(self.rr, text="CALCULAR", width=15, command=self.calculaterr).grid(row=13 + z, column=1)
        self.button1 = tk.Button(self.rr, text="SAIR", command=self.limpar).grid(row=13 + z, column=2)
        self.frame.grid()

    def Choices(self, choice):
        self.choice = choice
        tk.Label(self.rr, text="<---REQUERIMENTO APROVADO--->", font="verdana 10 ").grid(row=17, column=1)

    def voltar(self):
        self.rr.destroy()
        self.raiz.deiconify()

    def limpar(self):
        self.rr.destroy()
        self.raiz.destroy()

    #
    def calculaterr(self):
        self.rr.withdraw()
        self.calrr = tk.Toplevel(self.rr)
        self.calrr.geometry("+450+200")
        if (self.algo == "ROUND-ROBIN"):
            obj = RoundRobin(self.a11.get(), self.a22.get(), self.a33.get(), self.a44.get(), self.a55.get(),
                             self.b11.get(), self.b22.get(), self.b33.get(), self.b44.get(), self.b55.get(),
                             self.c11.get(), self.raiz, self.rr, self.calrr, self.algo)
            obj.processarDados()
        elif (self.algo == "FCFS"):
            obj = FCFS(self.a11.get(), self.a22.get(), self.a33.get(), self.a44.get(), self.a55.get(),
                       self.b11.get(),
                       self.b22.get(), self.b33.get(), self.b44.get(), self.b55.get(), self.raiz, self.rr,
                       self.calrr,
                       self.algo)
            obj.processarDados()
        elif (self.algo == "SJF"):
            obj = SJF(self.a11.get(), self.a22.get(), self.a33.get(), self.a44.get(), self.a55.get(),
                      self.b11.get(),
                      self.b22.get(), self.b33.get(), self.b44.get(), self.b55.get(), self.raiz, self.rr,
                      self.calrr,
                      self.algo)
            obj.processarDados()
        elif (self.algo == "SRTF"):
            obj = SRTF(self.a11.get(), self.a22.get(), self.a33.get(), self.a44.get(), self.a55.get(),
                       self.b11.get(),
                       self.b22.get(), self.b33.get(), self.b44.get(), self.b55.get(), self.raiz, self.rr,
                       self.calrr,
                       self.algo)
            obj.processarDados()
        elif (self.algo == "Priority"):
            obj = Prioridade(self.a11.get(), self.a22.get(), self.a33.get(), self.a44.get(), self.a55.get(),
                             self.b11.get(), self.b22.get(), self.b33.get(), self.b44.get(), self.b55.get(),
                             self.p11.get(), self.p22.get(), self.p33.get(), self.p44.get(), self.p55.get(),
                             self.raiz, self.rr, self.calrr, self.algo, self.choice)
            obj.processarDados()
        return


class Prioridade:
    def __init__(self, a1, a2, a3, a4, a5, b1, b2, b3, b4, b5, p1, p2, p3, p4, p5, raiz, rr, calrr, algo, choice):
        # Inicializa os atributos da classe com os parâmetros fornecidos
        self.a1 = a1
        self.a2 = a2
        self.a3 = a3
        self.a4 = a4
        self.a5 = a5
        self.b1 = b1
        self.b2 = b2
        self.b3 = b3
        self.b4 = b4
        self.b5 = b5
        self.raiz = raiz
        self.rr = rr
        self.calrr = calrr
        self.algo = algo
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3
        self.p4 = p4
        self.p5 = p5
        self.choice = choice

    def processarDados(self):
        # Processa os dados dos processos para serem utilizados no escalonamento
        dados_processo = []
        temporario = []
        id_processo = [1, 2, 3, 4, 5]
        tempo_chegada = [self.a1, self.a2, self.a3, self.a4, self.a5]
        tempo_execucao = [self.b1, self.b2, self.b3, self.b4, self.b5]
        prioridade = [self.p1, self.p2, self.p3, self.p4, self.p5]
        for i in range(5):
            temporario.extend([id_processo[i], tempo_chegada[i], tempo_execucao[i], 0, prioridade[i]])
            dados_processo.append(temporario)
            temporario = []
        self.escalonarProcessos(dados_processo)

    def escalonarProcessos(self, dados_processo):
        # Realiza o escalonamento dos processos com base nas prioridades
        tempo_atual = 0
        dados_processo.sort(key=lambda x: x[1])  # Ordena os processos por tempo de chegada
        for i in range(5):
            fila_pronta = []
            fila_normal = []
            for j in range(5):
                if (dados_processo[j][1] <= tempo_atual and dados_processo[j][3] == 0):
                    fila_pronta.append([dados_processo[j][0], dados_processo[j][1], dados_processo[j][2], dados_processo[j][4]])
                elif (dados_processo[j][3] == 0):
                    fila_normal.append([dados_processo[j][0], dados_processo[j][1], dados_processo[j][2], dados_processo[j][4]])
            if len(fila_pronta) != 0:
                if self.choice == "MV":
                    fila_pronta.sort(key=lambda x: x[3], reverse=True)  # Ordena por prioridade (maior valor primeiro)
                elif self.choice == "VL":
                    fila_pronta.sort(key=lambda x: x[3])  # Ordena por prioridade (menor valor primeiro)
                tempo_atual = tempo_atual + fila_pronta[0][2]  # Atualiza o tempo de execução
                for k in range(len(dados_processo)):
                    if dados_processo[k][0] == fila_pronta[0][0]:
                        break
                dados_processo[k][3] = 1  # Marca o processo como executado
                dados_processo[k].append(tempo_atual)  # Adiciona o tempo de término do processo
            elif len(fila_pronta) == 0:
                if tempo_atual < fila_normal[0][1]:
                    tempo_atual = fila_normal[0][1]
                tempo_atual = tempo_atual + fila_normal[0][2]
                for k in range(len(dados_processo)):
                    if dados_processo[k][0] == fila_normal[0][0]:
                        break
                dados_processo[k][3] = 1
                dados_processo[k].append(tempo_atual)
        tempo_retorno_medio = self.calcularTempoRetorno(dados_processo)  # Calcula o tempo de retorno médio
        tempo_espera_medio = self.calcularTempoEspera(dados_processo)  # Calcula o tempo de espera médio
        d = ExibirDados(self.raiz, self.rr, self.calrr, dados_processo, tempo_retorno_medio, tempo_espera_medio, 0, self.algo)  # Exibe os resultados
        d.exibir()

    def calcularTempoRetorno(self, dados_processo):
        # Calcula o tempo de retorno médio dos processos
        tempo_total_retorno = 0
        for i in range(len(dados_processo)):
            tempo_retorno = dados_processo[i][5] - dados_processo[i][1]  # Tempo de término - Tempo de chegada
            tempo_total_retorno = tempo_total_retorno + tempo_retorno
            dados_processo[i].append(tempo_retorno)
        tempo_retorno_medio = tempo_total_retorno / 5
        return tempo_retorno_medio

    def calcularTempoEspera(self, dados_processo):
        # Calcula o tempo de espera médio dos processos
        tempo_total_espera = 0
        for i in range(len(dados_processo)):
            tempo_espera = dados_processo[i][6] - dados_processo[i][2]  # Tempo de término de execução - Tempo de burst
            tempo_total_espera = tempo_total_espera + tempo_espera
            dados_processo[i].append(tempo_espera)
        tempo_espera_medio = tempo_total_espera / 5
        return tempo_espera_medio


class SRTF:
    def __init__(self, a1, a2, a3, a4, a5, b1, b2, b3, b4, b5, raiz, rr, calrr, algo):
        # Inicializa os atributos da classe com os parâmetros fornecidos
        self.a1 = a1
        self.a2 = a2
        self.a3 = a3
        self.a4 = a4
        self.a5 = a5
        self.b1 = b1
        self.b2 = b2
        self.b3 = b3
        self.b4 = b4
        self.b5 = b5
        self.raiz = raiz
        self.rr = rr
        self.calrr = calrr
        self.algo = algo

    def processarDados(self):
        # Processa os dados dos processos para serem utilizados no escalonamento
        dados_processo = []
        temporario = []
        id_processo = [1, 2, 3, 4, 5]
        tempo_chegada = [self.a1, self.a2, self.a3, self.a4, self.a5]
        tempo_execucao = [self.b1, self.b2, self.b3, self.b4, self.b5]
        for i in range(5):
            temporario.extend([id_processo[i], tempo_chegada[i], tempo_execucao[i], 0, tempo_execucao[i]])
            dados_processo.append(temporario)
            temporario = []
        self.escalonarProcessos(dados_processo)

    def escalonarProcessos(self, dados_processo):
        # Realiza o escalonamento dos processos pelo menor tempo restante
        inicio_execucao = []
        fim_execucao = []
        tempo_atual = 0
        sequencia_de_processos = []
        dados_processo.sort(key=lambda x: x[1])  # Ordena os processos por tempo de chegada
        while 1:
            fila_pronta = []
            fila_normal = []
            temp = []
            for i in range(len(dados_processo)):
                if dados_processo[i][1] <= tempo_atual and dados_processo[i][3] == 0:
                    temp.extend([dados_processo[i][0], dados_processo[i][1], dados_processo[i][2], dados_processo[i][4]])
                    fila_pronta.append(temp)
                    temp = []
                elif dados_processo[i][3] == 0:
                    temp.extend([dados_processo[i][0], dados_processo[i][1], dados_processo[i][2], dados_processo[i][4]])
                    fila_normal.append(temp)
                    temp = []
            if len(fila_pronta) == 0 and len(fila_normal) == 0:
                break
            if len(fila_pronta) != 0:
                fila_pronta.sort(key=lambda x: x[2])  # Ordena a fila pelos menores tempos restantes
                inicio_execucao.append(tempo_atual)
                tempo_atual = tempo_atual + 1
                fim_execucao.append(tempo_atual)
                sequencia_de_processos.append(fila_pronta[0][0])
                for k in range(len(dados_processo)):
                    if dados_processo[k][0] == fila_pronta[0][0]:
                        break
                dados_processo[k][2] = dados_processo[k][2] - 1  # Reduz o tempo restante de execução
                if dados_processo[k][2] == 0:
                    dados_processo[k][3] = 1  # Marca o processo como concluído
                    dados_processo[k].append(tempo_atual)  # Adiciona o tempo de término do processo
            if len(fila_pronta) == 0:
                if tempo_atual < fila_normal[0][1]:
                    tempo_atual = fila_normal[0][1]
                inicio_execucao.append(tempo_atual)
                tempo_atual = tempo_atual + 1
                fim_execucao.append(tempo_atual)
                sequencia_de_processos.append(fila_normal[0][0])
                for k in range(len(dados_processo)):
                    if dados_processo[k][0] == fila_normal[0][0]:
                        break
                dados_processo[k][2] = dados_processo[k][2] - 1
                if dados_processo[k][2] == 0:
                    dados_processo[k][3] = 1
                    dados_processo[k].append(tempo_atual)
        tempo_retorno_medio = self.calcularTempoRetorno(dados_processo)  # Calcula o tempo de retorno médio
        tempo_espera_medio = self.calcularTempoEspera(dados_processo)  # Calcula o tempo de espera médio
        d = ExibirDados(self.raiz, self.rr, self.calrr, dados_processo, tempo_retorno_medio, tempo_espera_medio, sequencia_de_processos, self.algo)  # Exibe os resultados
        d.exibir()

    def calcularTempoRetorno(self, dados_processo):
        # Calcula o tempo de retorno médio dos processos
        tempo_total_retorno = 0
        for i in range(len(dados_processo)):
            tempo_retorno = dados_processo[i][5] - dados_processo[i][1]  # Tempo de término - Tempo de chegada
            tempo_total_retorno = tempo_total_retorno + tempo_retorno
            dados_processo[i].append(tempo_retorno)
        tempo_retorno_medio = tempo_total_retorno / 5
        return tempo_retorno_medio

    def calcularTempoEspera(self, dados_processo):
        # Calcula o tempo de espera médio dos processos
        tempo_total_espera = 0
        for i in range(len(dados_processo)):
            tempo_espera = dados_processo[i][6] - dados_processo[i][2]  # Tempo de término de execução - Tempo de burst
            tempo_total_espera = tempo_total_espera + tempo_espera
            dados_processo[i].append(tempo_espera)
        tempo_espera_medio = tempo_total_espera / 5
        return tempo_espera_medio



class FCFS:
    def __init__(self, a1, a2, a3, a4, a5, b1, b2, b3, b4, b5, raiz, rr, calrr, algo):
        # Inicializa os atributos da classe com os parâmetros fornecidos
        self.a1 = a1
        self.a2 = a2
        self.a3 = a3
        self.a4 = a4
        self.a5 = a5
        self.b1 = b1
        self.b2 = b2
        self.b3 = b3
        self.b4 = b4
        self.b5 = b5
        self.raiz = raiz
        self.rr = rr
        self.calrr = calrr
        self.algo = algo

    def processarDados(self):
        # Processa os dados dos processos para serem utilizados no escalonamento
        dados_processo = []
        temporario = []
        id_processo = [1, 2, 3, 4, 5]
        tempo_chegada = [self.a1, self.a2, self.a3, self.a4, self.a5]
        tempo_execucao = [self.b1, self.b2, self.b3, self.b4, self.b5]
        for i in range(5):
            temporario.extend([id_processo[i], tempo_chegada[i], tempo_execucao[i], 0, 0])
            dados_processo.append(temporario)
            temporario = []
        self.escalonarProcessos(dados_processo)

    def escalonarProcessos(self, dados_processo):
        # Realiza o escalonamento dos processos pelo método First Come First Serve (FCFS)
        inicio_execucao = []
        fim_execucao = []
        tempo_atual = 0
        dados_processo.sort(key=lambda x: x[1])  # Ordena os processos por tempo de chegada
        for i in range(len(dados_processo)):
            inicio_execucao.append(tempo_atual)
            tempo_atual = tempo_atual + dados_processo[i][2]  # Adiciona o tempo de burst ao tempo de início
            fim_execucao.append(tempo_atual)
            dados_processo[i].append(tempo_atual)  # Adiciona o tempo de término ao processo
        tempo_retorno_medio = self.calcularTempoRetorno(dados_processo)  # Calcula o tempo de retorno médio
        tempo_espera_medio = self.calcularTempoEspera(dados_processo)  # Calcula o tempo de espera médio
        d = ExibirDados(self.raiz, self.rr, self.calrr, dados_processo, tempo_retorno_medio, tempo_espera_medio, 0, self.algo)  # Exibe os resultados
        d.exibir()

    def calcularTempoRetorno(self, dados_processo):
        # Calcula o tempo de retorno médio dos processos
        tempo_total_retorno = 0
        for i in range(5):
            tempo_retorno = dados_processo[i][5] - dados_processo[i][1]  # Tempo de término - Tempo de chegada
            tempo_total_retorno = tempo_total_retorno + tempo_retorno
            dados_processo[i].append(tempo_retorno)
        tempo_retorno_medio = tempo_total_retorno / 5
        return tempo_retorno_medio

    def calcularTempoEspera(self, dados_processo):
        # Calcula o tempo de espera médio dos processos
        tempo_total_espera = 0
        for i in range(len(dados_processo)):
            tempo_espera = dados_processo[i][6] - dados_processo[i][2]  # Tempo de término de execução - Tempo de burst
            tempo_total_espera = tempo_total_espera + tempo_espera
            dados_processo[i].append(tempo_espera)
        tempo_espera_medio = tempo_total_espera / 5
        return tempo_espera_medio



class SJF:
    def __init__(self, a1, a2, a3, a4, a5, b1, b2, b3, b4, b5, raiz, rr, calrr, algo):
        # Inicializa os atributos da classe com os parâmetros fornecidos
        self.a1 = a1
        self.a2 = a2
        self.a3 = a3
        self.a4 = a4
        self.a5 = a5
        self.b1 = b1
        self.b2 = b2
        self.b3 = b3
        self.b4 = b4
        self.b5 = b5
        self.raiz = raiz
        self.rr = rr
        self.calrr = calrr
        self.algo = algo

    def processarDados(self):
        # Processa os dados dos processos para serem utilizados no escalonamento
        dados_processo = []
        temporario = []
        id_processo = [1, 2, 3, 4, 5]
        tempo_chegada = [self.a1, self.a2, self.a3, self.a4, self.a5]
        tempo_execucao = [self.b1, self.b2, self.b3, self.b4, self.b5]
        for i in range(5):
            temporario.extend([id_processo[i], tempo_chegada[i], tempo_execucao[i], 0, 0])
            dados_processo.append(temporario)
            temporario = []
        self.escalonarProcessos(dados_processo)

    def escalonarProcessos(self, dados_processo):
        # Realiza o escalonamento dos processos pelo método Shortest Job First (SJF)
        tempo_atual = 0
        dados_processo.sort(key=lambda x: x[1])  # Ordena os processos por tempo de chegada
        for i in range(5):
            fila_pronta = []
            fila_normal = []
            for j in range(5):
                if (dados_processo[j][1] <= tempo_atual) and (dados_processo[j][3] == 0):
                    fila_pronta.append([dados_processo[j][0], dados_processo[j][1], dados_processo[j][2]])
                elif dados_processo[j][3] == 0:
                    fila_normal.append([dados_processo[j][0], dados_processo[j][1], dados_processo[j][2]])
            if len(fila_pronta) != 0:
                fila_pronta.sort(key=lambda x: x[2])  # Ordena a fila pronta pelo tempo de burst
                tempo_atual = tempo_atual + fila_pronta[0][2]  # Adiciona o tempo de burst ao tempo atual
                for k in range(5):
                    if fila_pronta[0][0] == dados_processo[k][0]:
                        break
                dados_processo[k][3] = 1  # Marca o processo como executado
                dados_processo[k].append(tempo_atual)  # Adiciona o tempo de término ao processo
            elif len(fila_pronta) == 0:
                if fila_normal[0][1] > tempo_atual:
                    tempo_atual = fila_normal[0][1]  # Atualiza o tempo atual para o próximo processo na fila normal
                tempo_atual = tempo_atual + fila_normal[0][2]  # Adiciona o tempo de burst ao tempo atual
                for k in range(len(dados_processo)):
                    if dados_processo[k][0] == fila_normal[0][0]:
                        break
                dados_processo[k][3] = 1  # Marca o processo como executado
                dados_processo[k].append(tempo_atual)  # Adiciona o tempo de término ao processo
        tempo_retorno_medio = self.calcularTempoRetorno(dados_processo)  # Calcula o tempo de retorno médio
        tempo_espera_medio = self.calcularTempoEspera(dados_processo)  # Calcula o tempo de espera médio
        d = ExibirDados(self.raiz, self.rr, self.calrr, dados_processo, tempo_retorno_medio, tempo_espera_medio, 0, self.algo)  # Exibe os resultados
        d.exibir()

    def calcularTempoRetorno(self, dados_processo):
        # Calcula o tempo de retorno médio dos processos
        tempo_total_retorno = 0
        for i in range(5):
            tempo_retorno = dados_processo[i][5] - dados_processo[i][1]  # Tempo de término - Tempo de chegada
            tempo_total_retorno = tempo_total_retorno + tempo_retorno
            dados_processo[i].append(tempo_retorno)
        tempo_retorno_medio = tempo_total_retorno / 5
        return tempo_retorno_medio

    def calcularTempoEspera(self, dados_processo):
        # Calcula o tempo de espera médio dos processos
        tempo_total_espera = 0
        for i in range(len(dados_processo)):
            tempo_espera = dados_processo[i][6] - dados_processo[i][2]  # Tempo de término de execução - Tempo de burst
            tempo_total_espera = tempo_total_espera + tempo_espera
            dados_processo[i].append(tempo_espera)
        tempo_espera_medio = tempo_total_espera / len(dados_processo)  # Calcular a média
        return tempo_espera_medio  # Retornar o tempo de espera médio


class RoundRobin:
    def __init__(self, a1, a2, a3, a4, a5, b1, b2, b3, b4, b5, t, raiz, rr, calrr, algo):
        # Inicializa os atributos da classe com os parâmetros fornecidos
        self.a1 = a1
        self.a2 = a2
        self.a3 = a3
        self.a4 = a4
        self.a5 = a5
        self.b1 = b1
        self.b2 = b2
        self.b3 = b3
        self.b4 = b4
        self.b5 = b5
        self.raiz = raiz
        self.rr = rr
        self.calrr = calrr
        self.algo = algo
        self.t = t

    def processarDados(self):
        # Processa os dados dos processos para serem utilizados no escalonamento
        dados_processo = []
        temporario = []
        id_processo = [1, 2, 3, 4, 5]
        tempo_chegada = [self.a1, self.a2, self.a3, self.a4, self.a5]
        tempo_execucao = [self.b1, self.b2, self.b3, self.b4, self.b5]

        for i in range(5):
            temporario.extend([id_processo[i], tempo_chegada[i], tempo_execucao[i], 0, tempo_execucao[i]])
            dados_processo.append(temporario)
            temporario = []
        fatia_tempo = self.t
        self.escalonarProcessos(dados_processo, fatia_tempo)

    def escalonarProcessos(self, dados_processo, fatia_tempo):
        # Realiza o escalonamento dos processos pelo método Round Robin (RR)
        tempo_inicio = []
        tempo_saida = []
        processos_executados = []
        fila_pronta = []
        s_time = 0
        dados_processo.sort(key=lambda x: x[1])  # Ordena os processos por tempo de chegada
        while 1:
            fila_normal = []
            temp = []
            for i in range(len(dados_processo)):
                if dados_processo[i][1] <= s_time and dados_processo[i][3] == 0:
                    presente = 0
                    if len(fila_pronta) != 0:
                        for k in range(len(fila_pronta)):
                            if dados_processo[i][0] == fila_pronta[k][0]:
                                presente = 1
                    if presente == 0:
                        temp.extend([dados_processo[i][0], dados_processo[i][1], dados_processo[i][2], dados_processo[i][4]])
                        fila_pronta.append(temp)
                        temp = []
                    if len(fila_pronta) != 0 and len(processos_executados) != 0:
                        for k in range(len(fila_pronta)):
                            if fila_pronta[k][0] == processos_executados[len(processos_executados) - 1]:
                                fila_pronta.insert((len(fila_pronta) - 1), fila_pronta.pop(k))
                elif dados_processo[i][3] == 0:
                    temp.extend([dados_processo[i][0], dados_processo[i][1], dados_processo[i][2], dados_processo[i][4]])
                    fila_normal.append(temp)
                    temp = []
            if len(fila_pronta) == 0 and len(fila_normal) == 0:
                break
            if len(fila_pronta) != 0:
                if fila_pronta[0][2] > fatia_tempo:
                    tempo_inicio.append(s_time)
                    s_time = s_time + fatia_tempo
                    e_time = s_time
                    tempo_saida.append(e_time)
                    processos_executados.append(fila_pronta[0][0])
                    for j in range(len(dados_processo)):
                        if dados_processo[j][0] == fila_pronta[0][0]:
                            break
                    dados_processo[j][2] = dados_processo[j][2] - fatia_tempo
                    fila_pronta.pop(0)
                elif fila_pronta[0][2] <= fatia_tempo:
                    tempo_inicio.append(s_time)
                    s_time = s_time + fila_pronta[0][2]
                    e_time = s_time
                    tempo_saida.append(e_time)
                    processos_executados.append(fila_pronta[0][0])
                    for j in range(len(dados_processo)):
                        if dados_processo[j][0] == fila_pronta[0][0]:
                            break
                    dados_processo[j][2] = 0
                    dados_processo[j][3] = 1
                    dados_processo[j].append(e_time)
                    fila_pronta.pop(0)
            elif len(fila_pronta) == 0:
                if s_time < fila_normal[0][1]:
                    s_time = fila_normal[0][1]
                if fila_normal[0][2] > fatia_tempo:
                    tempo_inicio.append(s_time)
                    s_time = s_time + fatia_tempo
                    e_time = s_time
                    tempo_saida.append(e_time)
                    processos_executados.append(fila_normal[0][0])
                    for j in range(len(dados_processo)):
                        if dados_processo[j][0] == fila_normal[0][0]:
                            break
                    dados_processo[j][2] = dados_processo[j][2] - fatia_tempo
                elif fila_normal[0][2] <= fatia_tempo:
                    tempo_inicio.append(s_time)
                    s_time = s_time + fila_normal[0][2]
                    e_time = s_time
                    tempo_saida.append(e_time)
                    processos_executados.append(fila_normal[0][0])
                    for j in range(len(dados_processo)):
                        if dados_processo[j][0] == fila_normal[0][0]:
                            break
                    dados_processo[j][2] = 0
                    dados_processo[j][3] = 1
                    dados_processo[j].append(e_time)
        t_time = RoundRobin.calcularTempoRetorno(self, dados_processo)  # Calcula o tempo de retorno médio
        w_time = RoundRobin.calcularTempoEspera(self, dados_processo)  # Calcula o tempo de espera médio
        d = ExibirDados(self.raiz, self.rr, self.calrr, dados_processo, t_time, w_time, processos_executados, self.algo)  # Exibe os resultados
        d.exibir()

    def calcularTempoRetorno(self, dados_processo):
        # Calcula o tempo de retorno médio dos processos
        tempo_total_retorno = 0
        for i in range(len(dados_processo)):
            tempo_retorno = dados_processo[i][5] - dados_processo[i][1]  # Tempo de término - Tempo de chegada
            tempo_total_retorno = tempo_total_retorno + tempo_retorno
            dados_processo[i].append(tempo_retorno)
        tempo_retorno_medio = tempo_total_retorno / 5
        return tempo_retorno_medio

    def calcularTempoEspera(self, dados_processo):
        # Calcula o tempo de espera médio dos processos
        tempo_total_espera = 0
        for i in range(len(dados_processo)):
            tempo_espera = dados_processo[i][6] - dados_processo[i][4]  # Tempo de término de execução - Tempo de burst original
            tempo_total_espera = tempo_total_espera + tempo_espera
            dados_processo[i].append(tempo_espera)
        tempo_espera_medio = tempo_total_espera / 5
        return tempo_espera_medio




class ExibirDados:
    def __init__(self, raiz, rr, calrr, p, t, w, e, algo):
        self.raiz = raiz
        self.rr = rr
        self.calrr = calrr
        self.dados_processo = p
        self.tempo_total = t
        self.tempo_total_espera = w
        self.processos_executados = e
        self.algoritmo = algo

    def exibir(self):
        self.dados_processo.sort(key=lambda x: x[0])
        tk.Label(self.calrr, text=" ").grid(row=0, column=0)
        tk.Label(self.calrr, text="PROCESSOS").grid(row=1, column=0)
        tk.Label(self.calrr, text="TEMPO DE CONCLUSÃO   ").grid(row=1, column=1)
        tk.Label(self.calrr, text="TEMPO DE RESPOSTA  ", font="verdana 11 ").grid(row=1, column=2)
        tk.Label(self.calrr, text="TEMPO DE ESPERA", font="verdana 11 ").grid(row=1, column=3)
        tk.Label(self.calrr, text=" ").grid(row=2, column=0)

        for i in range(len(self.dados_processo)):
            tk.Label(self.calrr, text=f"P{i+1} :", font="verdana 10 ").grid(row=i*2+3, column=0)
            tk.Label(self.calrr, text=self.dados_processo[i][5], font="verdana 10 bold").grid(row=i*2+3, column=1)
            tk.Label(self.calrr, text=self.dados_processo[i][6], font="verdana 10 bold").grid(row=i*2+3, column=2)
            tk.Label(self.calrr, text=self.dados_processo[i][7], font="verdana 10 bold").grid(row=i*2+3, column=3)
            tk.Label(self.calrr, text=" ").grid()

        tk.Label(self.calrr, text="TEMPO MÉDIO DE VOLTA:", font="verdana 10").grid(row=len(self.dados_processo)*2+3, column=0)
        tk.Label(self.calrr, text=self.tempo_total, font="verdana 10 bold").grid(row=len(self.dados_processo)*2+3, column=1)
        tk.Label(self.calrr, text=" ").grid(row=len(self.dados_processo)*2+4, column=0)
        tk.Label(self.calrr, text="TEMPO MÉDIO DE ESPERA    :", font="verdana 10").grid(row=len(self.dados_processo)*2+5, column=0)
        tk.Label(self.calrr, text=self.tempo_total_espera, font="verdana 10 bold").grid(row=len(self.dados_processo)*2+5, column=1)
        tk.Label(self.calrr, text=" ").grid(row=len(self.dados_processo)*2+6, column=0)

        if self.algoritmo == "ROUND-ROBIN" or self.algoritmo == "SRTF":
            tk.Label(self.calrr, text="SEQUÊNCIA DO PROCESSO     :", font="verdana 10").grid(row=len(self.dados_processo)*2+7, column=0)
            tk.Label(self.calrr, text=str(self.processos_executados), font="verdana 10 bold").grid(row=len(self.dados_processo)*2+7, column=1)
            tk.Label(self.calrr, text=" ").grid(row=len(self.dados_processo)*2+8, column=0)

        tk.Button(self.calrr, text="VOLTAR AO MENU", font="verdana 11 ", width=15, command=self.voltar_menu).grid(row=len(self.dados_processo)*2+9, column=0)
        tk.Label(self.raiz, text="").grid()
        tk.Button(self.calrr, text=f"VOLTAR AO {self.algoritmo}", font="verdana 11 ", width=18, command=self.voltar).grid(row=len(self.dados_processo)*2+9, column=1)
        tk.Label(self.raiz, text="").grid()
        tk.Button(self.calrr, text="SAIR", font="verdana 11", width=15, command=self.sair).grid(row=len(self.dados_processo)*2+9, column=2)
        tk.Label(self.raiz, text="").grid()

    def voltar(self):
        self.calrr.destroy()
        self.rr.deiconify()

    def sair(self):
        self.calrr.destroy()
        self.rr.destroy()
        self.raiz.destroy()

    def voltar_menu(self):
        self.calrr.destroy()
        self.rr.destroy()
        self.raiz.deiconify()


if __name__ == "__main__":
    raiz = tk.Tk()
    janela = JanelaPrincipal(raiz)

#    janela.exibir()
    raiz.mainloop()

